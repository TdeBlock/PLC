TYPE "udtSequence_HMI"
VERSION : 0.1
   STRUCT
      rpt_SequenceTime : Time;
      cmd : Struct
         Start : Bool;
         Stop : Bool;
         Pause : Bool;
         Resume : Bool;
      END_STRUCT;
      rpt_CurrentStep : DInt;
      rpt : Struct
         CurrentStep : Int;
         SequenceTIme : Time;
         State : Int;
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "fb_Sequence"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      inCond_01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transition conditions for step 1
      inCond_02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transition conditions for step 2
      inCond_03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transition conditions for step 3
      inCond_04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transition conditions for step 4
      inCond_05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transition conditions for step 5
      inCond_06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transition conditions for step 6
      inCond_07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transition conditions for step 7
      inCond_08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transition conditions for step 8
      inRunPerms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Run permissions
      inStartPerms { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start permissions
   END_VAR
   VAR_INPUT RETAIN
      Params { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         StepDelay_01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Delay after transition conditions are met
         StepDisable_01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable this step. Step will be skipped
         StepDelay_02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Delay after transition conditions are met
         StepDisable_02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable this step. Step will be skipped
         StepDelay_03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Delay after transition conditions are met
         StepDisable_03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable this step. Step will be skipped
         StepDelay_04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Delay after transition conditions are met
         StepDisable_04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable this step. Step will be skipped
         StepDelay_05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Delay after transition conditions are met
         StepDisable_05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable this step. Step will be skipped
         StepDelay_06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Delay after transition conditions are met
         StepDisable_06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable this step. Step will be skipped
         StepDelay_07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Delay after transition conditions are met
         StepDisable_07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable this step. Step will be skipped
         StepDelay_08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Delay after transition conditions are met
         StepDisable_08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Disable this step. Step will be skipped
         MaxStepTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Sequence will go to paused state when this time is exceeded
         RunContinuously { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Repeat cycle until stop command is given
         StepCycle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Wait in each step until the start command is given again
      END_STRUCT;
   END_VAR
   VAR_INPUT 
      Cmd { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Start running the sequence from state Idle
         Stop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop running and go to Idle state
         Pause { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Continue the sequence from paused to running state
         Restart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Set the sequence to Paused state
      END_STRUCT;
   END_VAR

   VAR_OUTPUT 
      outAction_01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Action for step 1
      outAction_02 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Action for step 2
      outAction_03 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Action for step 3
      outAction_04 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Action for step 4
      outAction_05 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Action for step 5
      outAction_06 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Action for step 6
      outAction_07 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Action for step 7
      outAction_08 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Action for step 8
      Sts { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Idle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Waiting for start command
         Running { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sequence in progress
         Paused { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Sequence pause due to transition time-out or pause command
         Stopped { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Waiting for run permissions before transitioning to idle
      END_STRUCT;
   END_VAR

   VAR_IN_OUT 
      HMI : "udtSequence_HMI";
   END_VAR

   VAR 
      _Step { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      _tmr_TotalTimer {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      _tmr_CycleWatchdog {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      _tmr_StepDelay {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      _RE_CmdStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      _RE_cmdPause { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      _StepMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      _CountAction { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      _ActionArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..30] of Bool;
      _StepDelay_Enable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      _StepDelay_Preset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      _CycleEnabled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	//Watchdog timer for duration of a step
	#_tmr_CycleWatchdog(IN := #Sts.Running,
	                    PT := #Params.MaxStepTime);
	
	//Total sequence timer
	#_tmr_TotalTimer(IN := #Sts.Running OR #Sts.Paused,
	                 PT := T#60M);
	
	//Step delay timer
	#_tmr_StepDelay(IN := #_StepDelay_Enable,
	                PT := #_StepDelay_Preset);
	
	//Start command
	IF #Cmd.Start THEN
	    IF #Sts.Idle AND #inRunPerms AND NOT #_RE_CmdStart THEN
	        #_CycleEnabled := TRUE;
	        #_RE_CmdStart := 1;
	    END_IF;
	    
	    //If paused resume operation with start command
	    IF #Sts.Paused AND NOT #_RE_CmdStart THEN
	        #_Step := ABS(#_Step);
	        #_RE_CmdStart := 1;
	    END_IF;
	ELSE
	    #_RE_CmdStart := 0;
	END_IF;
	
	//Stop command
	IF #Cmd.Stop THEN
	    #_CycleEnabled := FALSE;
	    #_StepDelay_Enable := 0;
	END_IF;
	
	//Pause command
	//If watchdog timer expires go to paused mode
	IF #Cmd.Pause OR #_tmr_CycleWatchdog.Q THEN
	    IF #Sts.Running AND NOT #_RE_cmdPause THEN
	        #_StepMem := #_Step;
	        #_Step := - #_Step;
	        #_RE_cmdPause := 1;
	    END_IF;
	ELSE
	    #_RE_cmdPause := 0;
	END_IF;
	
	//If start permissions are missing go to stop
	IF NOT #inStartPerms THEN
	    #_CycleEnabled := FALSE;
	    #_Step := 0;
	END_IF;
	
	CASE #_Step OF
	    0:  //Stopped
	        IF #inStartPerms THEN
	            #_Step := 5;
	        END_IF;
	        
	    5:  //Idle
	        IF #_CycleEnabled THEN
	            #_Step := 10;
	        END_IF;
	        
	    10:
	        IF #inCond_01 THEN //Running    
	            #_StepDelay_Preset := #Params.StepDelay_01;
	            #_StepDelay_Enable := 1;
	            IF #_tmr_StepDelay.Q THEN
	                #_Step := 20;
	                #_StepDelay_Enable := 0;
	            END_IF;
	        END_IF;
	        
	    20:
	        IF #inCond_02 THEN
	            #_StepDelay_Preset := #Params.StepDelay_02;
	            #_StepDelay_Enable := 1;
	            IF #_tmr_StepDelay.Q THEN
	                #_Step := 30;
	                #_StepDelay_Enable := 0;
	            END_IF;
	            
	        END_IF;
	        
	    30:
	        IF #inCond_03 THEN
	            #_StepDelay_Preset := #Params.StepDelay_03;
	            #_StepDelay_Enable := 1;
	            IF #_tmr_StepDelay.Q THEN
	                #_Step := 40;
	                #_StepDelay_Enable := 0;
	            END_IF;
	        END_IF;
	        
	    40:
	        IF #inCond_04 THEN
	            #_StepDelay_Preset := #Params.StepDelay_04;
	            #_StepDelay_Enable := 1;
	            IF #_tmr_StepDelay.Q THEN
	                #_Step := 50;
	                #_StepDelay_Enable := 0;
	            END_IF;
	            
	        END_IF;
	        
	    50:
	        IF #inCond_05 THEN
	            #_StepDelay_Preset := #Params.StepDelay_05;
	            #_StepDelay_Enable := 1;
	            IF #_tmr_StepDelay.Q THEN
	                #_Step := 60;
	                #_StepDelay_Enable := 0;
	            END_IF;
	            
	        END_IF;
	        
	    60:
	        IF #inCond_06 THEN
	            #_StepDelay_Preset := #Params.StepDelay_06;
	            #_StepDelay_Enable := 1;
	            IF #_tmr_StepDelay.Q THEN
	                #_Step := 70;
	                #_StepDelay_Enable := 0;
	            END_IF;
	            
	        END_IF;
	        
	    70:
	        IF #inCond_07 THEN
	            #_StepDelay_Preset := #Params.StepDelay_07;
	            #_StepDelay_Enable := 1;
	            IF #_tmr_StepDelay.Q THEN
	                #_Step := 80;
	                #_StepDelay_Enable := 0;
	            END_IF;
	        END_IF;
	        
	    80:
	        IF #inCond_08 THEN
	            #_StepDelay_Preset := #Params.StepDelay_08;
	            #_StepDelay_Enable := 1;
	            IF #_tmr_StepDelay.Q THEN
	                #_Step := 0;
	                #_StepDelay_Enable := 0;
	                
	                //Display sequence time
	                #HMI.#rpt_SequenceTime := #_tmr_TotalTimer.ET;
	            END_IF;
	        END_IF;
	        
	        //ELSE //When paused the step number is negated
	        
	END_CASE;
	
	//Set correct action one at a time
	//When paused still keep the current step number active
	IF #Sts.Paused THEN
	    FOR #_CountAction := 10 TO 80 BY 10 DO
	        IF #_StepMem = #_CountAction THEN
	            #_ActionArray[#_CountAction / 10] := 1;
	        ELSE
	            #_ActionArray[#_CountAction / 10] := 0;
	        END_IF;
	    END_FOR;
	ELSE
	    FOR #_CountAction := 10 TO 80 BY 10 DO
	        IF #_Step = #_CountAction THEN
	            #_ActionArray[#_CountAction / 10] := 1;
	        ELSE
	            #_ActionArray[#_CountAction / 10] := 0;
	        END_IF;
	    END_FOR;
	END_IF;
	
	//Update actions according to array
	#outAction_01 := #_ActionArray[1];
	#outAction_02 := #_ActionArray[2];
	#outAction_03 := #_ActionArray[3];
	#outAction_04 := #_ActionArray[4];
	#outAction_05 := #_ActionArray[5];
	#outAction_06 := #_ActionArray[6];
	#outAction_07 := #_ActionArray[7];
	#outAction_08 := #_ActionArray[8];
	
	//Update status
	IF #_Step = 0 THEN
	    #Sts.Idle := 0;
	    #Sts.Running := 0;
	    #Sts.Paused := 0;
	    #Sts.Stopped := 1;
	ELSIF #_Step = 5 THEN
	    #Sts.Idle := 1;
	    #Sts.Running := 0;
	    #Sts.Paused := 0;
	    #Sts.Stopped := 0;
	ELSIF #_Step < 0 THEN
	    #Sts.Idle := 0;
	    #Sts.Running := 0;
	    #Sts.Paused := 1;
	    #Sts.Stopped := 0;
	ELSE
	    #Sts.Idle := 0;
	    #Sts.Running := 1;
	    #Sts.Paused := 0;
	    #Sts.Stopped := 0;
	END_IF;
	
	//Send values to HMI
	#HMI.rpt_CurrentStep := #_Step;
	#HMI.rpt_SequenceTime := #_tmr_TotalTimer.ET;
	
	
END_FUNCTION_BLOCK

